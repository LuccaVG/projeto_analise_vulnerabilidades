#!/usr/bin/env python3
"""
Enhanced integration script for the Linux Vulnerability Analysis Toolkit.
This script integrates the new autoinstall.py with existing shell scripts and setup infrastructure.
"""

import os
import sys
import subprocess
import shutil
from pathlib import Path

class ToolkitIntegrator:
    def __init__(self):
        self.project_root = Path(__file__).parent
        self.scripts_dir = self.project_root / "scripts"
        self.install_dir = self.project_root / "install"
        
    def integrate_shell_scripts(self):
        """Integrate the autoinstall.py with existing shell scripts."""
        print("🔧 Integrating with existing shell scripts...")
        
        # Create an enhanced setup_tools.sh that calls our autoinstall.py
        enhanced_setup = self.scripts_dir / "enhanced_setup.sh"
        
        shell_script_content = '''#!/bin/bash
# Enhanced setup script that integrates Python autoinstall with shell scripts
# Auto-generated by toolkit_integration.py

set -e  # Exit on any error

echo "🛡️  Linux Vulnerability Analysis Toolkit - Enhanced Setup"
echo "=========================================================="

# Check if we're on Linux
if [[ "$OSTYPE" != "linux-gnu"* ]]; then
    echo "❌ Error: This toolkit requires Linux. Current OS: $OSTYPE"
    echo "   Please run this on a Linux system (Kali, Ubuntu, Debian, Arch, etc.)"
    exit 1
fi

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

echo "📂 Project root: $PROJECT_ROOT"

# Check if Python 3 is available
if ! command -v python3 &> /dev/null; then
    echo "❌ Python 3 is required but not installed."
    echo "   Installing Python 3..."
    
    # Detect Linux distribution and install Python
    if command -v apt-get &> /dev/null; then
        sudo apt-get update
        sudo apt-get install -y python3 python3-pip
    elif command -v yum &> /dev/null; then
        sudo yum install -y python3 python3-pip
    elif command -v pacman &> /dev/null; then
        sudo pacman -S --noconfirm python python-pip
    else
        echo "❌ Could not detect package manager. Please install Python 3 manually."
        exit 1
    fi
fi

echo "✅ Python 3 is available"

# Run the main autoinstall.py script
echo "🚀 Running comprehensive auto-installation..."
cd "$PROJECT_ROOT"

if python3 autoinstall.py; then
    echo "✅ Auto-installation completed successfully!"
else
    echo "❌ Auto-installation failed. Trying fallback methods..."
    
    # Fallback to individual shell scripts
    echo "🔄 Trying fallback installation methods..."
    
    # Run existing shell scripts as fallback
    if [[ -f "$SCRIPT_DIR/setup_tools.sh" ]]; then
        echo "📦 Running fallback setup_tools.sh..."
        bash "$SCRIPT_DIR/setup_tools.sh"
    fi
    
    if [[ -f "$SCRIPT_DIR/fix_go_path.sh" ]]; then
        echo "🔧 Running fix_go_path.sh..."
        bash "$SCRIPT_DIR/fix_go_path.sh"
    fi
fi

# Verify installation
echo "🔍 Verifying installation..."
if python3 verify_installation.py; then
    echo "🎉 Installation verification completed!"
else
    echo "⚠️  Some verification checks failed. Please review the output above."
fi

# Create system-wide launcher if requested
read -p "🔗 Create system-wide launcher (/usr/local/bin/vulnscan)? [y/N]: " -n 1 -r
echo
if [[ $REPLY =~ ^[Yy]$ ]]; then
    echo "🔗 Creating system-wide launcher..."
    sudo bash -c "cat > /usr/local/bin/vulnscan << 'EOF'
#!/bin/bash
# Linux Vulnerability Analysis Toolkit Launcher
cd '$PROJECT_ROOT'
python3 src/workflow.py \"\$@\"
EOF"
    sudo chmod +x /usr/local/bin/vulnscan
    echo "✅ Launcher created! You can now run 'vulnscan --help' from anywhere."
fi

echo ""
echo "🎯 Setup complete! Next steps:"
echo "   1. Run: python3 src/workflow.py --help"
echo "   2. Test: python3 src/workflow.py --target example.com"
echo "   3. Full scan: python3 src/workflow.py --target your-target.com --output results/"
echo ""
'''
        
        with open(enhanced_setup, 'w') as f:
            f.write(shell_script_content)
        
        # Make it executable
        os.chmod(enhanced_setup, 0o755)
        print(f"✅ Created enhanced setup script: {enhanced_setup}")
        
    def create_dockerfile(self):
        """Create a Dockerfile for containerized deployment."""
        print("🐳 Creating Dockerfile for containerized deployment...")
        
        dockerfile_content = '''# Linux Vulnerability Analysis Toolkit - Docker Container
# Optimized for security testing with all tools pre-installed

FROM kalilinux/kali-rolling

# Set metadata
LABEL maintainer="Vulnerability Analysis Toolkit"
LABEL description="Automated Linux vulnerability scanning toolkit with naabu, httpx, and nuclei"
LABEL version="2.0"

# Set environment variables
ENV DEBIAN_FRONTEND=noninteractive
ENV GOPATH=/go
ENV PATH=$PATH:/go/bin:/usr/local/go/bin

# Update system and install base dependencies
RUN apt-get update && apt-get install -y \\
    python3 \\
    python3-pip \\
    wget \\
    curl \\
    git \\
    build-essential \\
    ca-certificates \\
    && rm -rf /var/lib/apt/lists/*

# Install Go
RUN wget -q https://go.dev/dl/go1.21.5.linux-amd64.tar.gz \\
    && tar -C /usr/local -xzf go1.21.5.linux-amd64.tar.gz \\
    && rm go1.21.5.linux-amd64.tar.gz

# Create working directory
WORKDIR /toolkit

# Copy project files
COPY . .

# Install Python dependencies
RUN pip3 install -r config/requirements.txt

# Run auto-installation
RUN python3 autoinstall.py --docker-mode

# Create non-root user for security
RUN useradd -m -s /bin/bash toolkit && \\
    chown -R toolkit:toolkit /toolkit /go

USER toolkit

# Set default command
CMD ["python3", "src/workflow.py", "--help"]

# Expose common ports for web interface (if implemented later)
EXPOSE 8080

# Add health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\
    CMD python3 verify_installation.py || exit 1
'''
        
        dockerfile_path = self.project_root / "Dockerfile"
        with open(dockerfile_path, 'w') as f:
            f.write(dockerfile_content)
        
        print(f"✅ Created Dockerfile: {dockerfile_path}")
        
    def create_docker_compose(self):
        """Create docker-compose.yml for easy deployment."""
        print("🐳 Creating docker-compose.yml...")
        
        compose_content = '''version: '3.8'

services:
  vulnscan:
    build: .
    container_name: vulnerability-scanner
    volumes:
      # Mount reports directory to persist results
      - ./reports:/toolkit/reports
      # Mount config for custom configurations
      - ./config:/toolkit/config
    environment:
      - PYTHONUNBUFFERED=1
    networks:
      - scan-network
    # Uncomment for interactive mode
    # stdin_open: true
    # tty: true
    
  # Optional: Web interface (for future implementation)
  # web-interface:
  #   build: 
  #     context: .
  #     dockerfile: Dockerfile.web
  #   ports:
  #     - "8080:8080"
  #   depends_on:
  #     - vulnscan
  #   networks:
  #     - scan-network

networks:
  scan-network:
    driver: bridge

volumes:
  scan-results:
    driver: local
'''
        
        compose_path = self.project_root / "docker-compose.yml"
        with open(compose_path, 'w') as f:
            f.write(compose_content)
        
        print(f"✅ Created docker-compose.yml: {compose_path}")
        
    def create_makefile(self):
        """Create a Makefile for easy project management."""
        print("🔨 Creating Makefile for project management...")
        
        makefile_content = '''# Linux Vulnerability Analysis Toolkit - Makefile
# Provides easy commands for installation, testing, and deployment

.PHONY: help install verify test clean docker-build docker-run lint format

# Default target
help:
	@echo "🛡️  Linux Vulnerability Analysis Toolkit"
	@echo "Available commands:"
	@echo "  make install    - Install all dependencies and tools"
	@echo "  make verify     - Verify installation"
	@echo "  make test       - Run tests"
	@echo "  make clean      - Clean temporary files"
	@echo "  make docker-build - Build Docker image"
	@echo "  make docker-run - Run in Docker container"
	@echo "  make lint       - Run code linting"
	@echo "  make format     - Format code"
	@echo "  make scan TARGET=<target> - Quick vulnerability scan"

# Installation
install:
	@echo "🔧 Installing Linux Vulnerability Analysis Toolkit..."
	python3 autoinstall.py

# Verification
verify:
	@echo "🔍 Verifying installation..."
	python3 verify_installation.py

# Testing
test:
	@echo "🧪 Running tests..."
	python3 -m pytest tests/ -v

# Clean temporary files
clean:
	@echo "🧹 Cleaning temporary files..."
	find . -type f -name "*.pyc" -delete
	find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
	find . -type f -name "temp_*.txt" -delete
	rm -rf .pytest_cache/
	rm -rf reports/temp_*

# Docker operations
docker-build:
	@echo "🐳 Building Docker image..."
	docker build -t vulnscan:latest .

docker-run:
	@echo "🐳 Running in Docker container..."
	docker-compose up --build

docker-shell:
	@echo "🐳 Opening shell in Docker container..."
	docker run -it --rm -v $(PWD)/reports:/toolkit/reports vulnscan:latest /bin/bash

# Code quality
lint:
	@echo "🔍 Running code linting..."
	python3 -m pylint src/ commands/ || true
	python3 -m flake8 src/ commands/ || true

format:
	@echo "✨ Formatting code..."
	python3 -m black src/ commands/ tests/ || true

# Quick scan command
scan:
	@if [ -z "$(TARGET)" ]; then \\
		echo "❌ Please specify TARGET: make scan TARGET=example.com"; \\
		exit 1; \\
	fi
	@echo "🎯 Scanning $(TARGET)..."
	python3 src/workflow.py --target $(TARGET) --output reports/scan_$(TARGET)_$(shell date +%Y%m%d_%H%M%S)

# Development setup
dev-setup:
	@echo "🛠️  Setting up development environment..."
	pip3 install -r config/requirements.txt
	pip3 install pylint flake8 black pytest
	pre-commit install || echo "pre-commit not available"

# System integration
system-install: install
	@echo "🔗 Creating system-wide installation..."
	sudo cp scripts/enhanced_setup.sh /usr/local/bin/vulnscan-setup
	sudo chmod +x /usr/local/bin/vulnscan-setup
	@echo "✅ Run 'vulnscan-setup' from anywhere to setup the toolkit"

# Update tools
update:
	@echo "🔄 Updating security tools..."
	go install github.com/projectdiscovery/naabu/v2/cmd/naabu@latest
	go install github.com/projectdiscovery/httpx/cmd/httpx@latest
	go install github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest
	nuclei -update-templates

# Security check
security-check:
	@echo "🔒 Running security checks..."
	python3 -m bandit -r src/ commands/ || true
'''
        
        makefile_path = self.project_root / "Makefile"
        with open(makefile_path, 'w') as f:
            f.write(makefile_content)
        
        print(f"✅ Created Makefile: {makefile_path}")
        
    def update_existing_setup(self):
        """Update the existing setup.py to integrate with our new system."""
        print("🔄 Updating existing setup.py...")
        
        setup_py_path = self.install_dir / "setup.py"
        
        if setup_py_path.exists():
            # Read existing setup.py
            with open(setup_py_path, 'r') as f:
                existing_content = f.read()
            
            # Add integration code at the beginning
            integration_code = '''#!/usr/bin/env python3
"""
Enhanced setup.py - Integrated with autoinstall.py
This script provides backward compatibility while leveraging the new auto-installation system.
"""

import os
import sys
from pathlib import Path

# Add project root to Python path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

def run_enhanced_setup():
    """Run the enhanced autoinstall.py script."""
    try:
        print("🚀 Running enhanced auto-installation system...")
        
        # Import and run autoinstall
        import autoinstall
        return autoinstall.main()
        
    except ImportError:
        print("⚠️  Enhanced autoinstall not available, falling back to original setup...")
        return False
    except Exception as e:
        print(f"❌ Enhanced setup failed: {e}")
        return False

# Try enhanced setup first
if __name__ == "__main__":
    if run_enhanced_setup():
        print("✅ Enhanced setup completed successfully!")
        sys.exit(0)
    else:
        print("🔄 Falling back to original setup method...")
        # Continue with original setup below

'''
            
            # Write the enhanced setup.py
            with open(setup_py_path, 'w') as f:
                f.write(integration_code + "\n# Original setup.py content:\n" + existing_content)
            
            print(f"✅ Updated existing setup.py with integration code")
        else:
            print("⚠️  No existing setup.py found, skipping integration")
    
    def create_comprehensive_readme(self):
        """Create an enhanced README with all the new features."""
        print("📖 Creating comprehensive README...")
        
        readme_content = '''# 🛡️ Linux Vulnerability Analysis Toolkit

**100% Automated Security Scanning Suite for Linux Systems**

[![Linux](https://img.shields.io/badge/Platform-Linux-blue)](https://www.linux.org/)
[![Python](https://img.shields.io/badge/Python-3.6+-green)](https://www.python.org/)
[![Go](https://img.shields.io/badge/Go-1.19+-00ADD8)](https://golang.org/)
[![License](https://img.shields.io/badge/License-MIT-yellow)](LICENSE)

## 🎯 Overview

This toolkit provides a **completely automated** vulnerability analysis solution for Linux systems. It automatically installs, configures, and orchestrates industry-standard security tools including **Naabu**, **HTTPX**, and **Nuclei**.

### ✨ Key Features

- 🤖 **100% Automated**: One-command installation and execution
- 🐧 **Linux-Only**: Optimized for Kali, Ubuntu, Debian, Arch Linux
- 🔧 **Auto-Installation**: Automatically installs all required tools and dependencies
- 🚀 **Modern Stack**: Leverages latest versions of Go-based security tools
- 📊 **Comprehensive Reporting**: JSON, HTML, and text output formats
- 🐳 **Docker Ready**: Containerized deployment available
- 🔄 **Self-Healing**: Automatically fixes common installation issues

## 🚀 Quick Start

### One-Command Installation
```bash
# Clone and auto-install everything
git clone <repository-url>
cd projeto_analise_vulnerabilidades
python3 autoinstall.py
```

### Quick Scan
```bash
# Scan a single target
python3 src/workflow.py --target example.com

# Scan with custom output
python3 src/workflow.py --target example.com --output results/
```

## 📋 Prerequisites

- **Linux Operating System** (Kali/Ubuntu/Debian/Arch)
- **Python 3.6+**
- **Internet Connection** (for tool downloads)
- **Root/Sudo Access** (for initial setup)

## 🔧 Installation Methods

### Method 1: Automatic Installation (Recommended)
```bash
python3 autoinstall.py
```

### Method 2: Enhanced Shell Script
```bash
bash scripts/enhanced_setup.sh
```

### Method 3: Docker Container
```bash
# Build and run
docker-compose up --build

# Or using make
make docker-run
```

### Method 4: Manual with Makefile
```bash
make install
make verify
```

## 🛠️ Tools Included

| Tool | Purpose | Auto-Install | Version |
|------|---------|--------------|---------|
| **Naabu** | Port Scanning | ✅ | Latest |
| **HTTPX** | HTTP Probing | ✅ | Latest |
| **Nuclei** | Vulnerability Scanning | ✅ | Latest |
| **Go** | Runtime Environment | ✅ | 1.21+ |

## 📖 Usage Examples

### Basic Scanning
```bash
# Single target scan
python3 src/workflow.py --target google.com

# Multiple targets from file
python3 src/workflow.py --target-list targets.txt

# Scan with all modules
python3 src/workflow.py --target example.com --naabu --httpx --nuclei
```

### Advanced Options
```bash
# Custom port range
python3 src/workflow.py --target example.com --ports "80,443,8080-8090"

# High-severity vulnerabilities only
python3 src/workflow.py --target example.com --severity critical,high

# JSON output
python3 src/workflow.py --target example.com --json --output results.json
```

### Using Individual Modules
```python
# Python API usage
from commands import naabu, httpx, nuclei

# Naabu port scan
naabu.run_naabu(target="example.com", ports="80,443", json_output=True)

# HTTPX web probing
httpx.run_httpx(target="example.com", tech_detect=True, title=True)

# Nuclei vulnerability scan
nuclei.run_nuclei(target="example.com", severity="high,critical")
```

## 🔍 Verification

Verify your installation at any time:
```bash
python3 verify_installation.py
```

## 🐳 Docker Usage

### Quick Start with Docker
```bash
# Build image
make docker-build

# Run container
make docker-run

# Interactive shell
make docker-shell
```

### Docker Compose
```bash
# Start services
docker-compose up -d

# View logs
docker-compose logs -f

# Stop services
docker-compose down
```

## 📁 Project Structure

```
projeto_analise_vulnerabilidades/
├── autoinstall.py              # Master auto-installation script
├── verify_installation.py      # Installation verification
├── Dockerfile                  # Container configuration
├── docker-compose.yml         # Multi-container setup
├── Makefile                   # Build automation
├── src/                       # Core modules
│   ├── workflow.py           # Main orchestrator
│   ├── utils.py              # Utility functions
│   └── ...
├── commands/                  # Tool wrappers
│   ├── naabu.py             # Naabu integration
│   ├── httpx.py             # HTTPX integration
│   └── nuclei.py            # Nuclei integration
├── scripts/                   # Shell scripts
│   ├── enhanced_setup.sh     # Enhanced setup
│   └── ...
├── config/                    # Configuration files
├── reports/                   # Scan results
└── docs/                     # Documentation
```

## 🎛️ Configuration

### Environment Variables
```bash
export GOPATH=$HOME/go
export PATH=$PATH:$GOPATH/bin
export NUCLEI_TEMPLATES_PATH=$HOME/nuclei-templates
```

### Custom Configuration
```python
# config/settings.py
DEFAULT_PORTS = "80,443,8080,8443"
DEFAULT_THREADS = 50
DEFAULT_TIMEOUT = 10
```

## 🚨 Troubleshooting

### Common Issues

**Go not found:**
```bash
# Run auto-installer
python3 autoinstall.py
```

**Tools not in PATH:**
```bash
# Fix PATH manually
export PATH=$PATH:~/go/bin
```

**Permission denied:**
```bash
# Ensure executable permissions
chmod +x scripts/*.sh
```

### Debug Mode
```bash
# Run with verbose output
python3 src/workflow.py --target example.com --verbose --debug
```

## 📊 Output Formats

### JSON Output
```json
{
  "target": "example.com",
  "scan_time": "2025-06-03T10:30:00Z",
  "results": {
    "ports": [80, 443],
    "technologies": ["nginx", "php"],
    "vulnerabilities": [...]
  }
}
```

### HTML Report
- Interactive dashboard
- Vulnerability details
- Remediation suggestions
- Export capabilities

## 🤝 Contributing

1. Fork the repository
2. Create feature branch (`git checkout -b feature/amazing-feature`)
3. Commit changes (`git commit -m 'Add amazing feature'`)
4. Push to branch (`git push origin feature/amazing-feature`)
5. Open Pull Request

## 📝 License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## ⚠️ Disclaimer

This tool is intended for **authorized security testing only**. Users are responsible for ensuring they have proper authorization before scanning any targets. The developers are not responsible for any misuse of this tool.

## 🙏 Acknowledgments

- [ProjectDiscovery](https://projectdiscovery.io/) for the amazing security tools
- [Kali Linux](https://www.kali.org/) team for the testing platform
- Open source security community

## 📞 Support

- 📧 Create an issue for bug reports
- 💬 Discussions for questions and ideas
- 📖 Check documentation in `/docs` folder

---

**Made with ❤️ for the cybersecurity community**
'''
        
        readme_path = self.project_root / "README_ENHANCED.md"
        with open(readme_path, 'w') as f:
            f.write(readme_content)
        
        print(f"✅ Created enhanced README: {readme_path}")

    def run_integration(self):
        """Run all integration tasks."""
        print("🔧 Starting toolkit integration...")
        
        try:
            self.integrate_shell_scripts()
            self.create_dockerfile()
            self.create_docker_compose()
            self.create_makefile()
            self.update_existing_setup()
            self.create_comprehensive_readme()
            
            print("\n🎉 Integration completed successfully!")
            print("\nNew files created:")
            print("  📜 scripts/enhanced_setup.sh - Enhanced setup script")
            print("  🐳 Dockerfile - Container configuration")
            print("  🐳 docker-compose.yml - Multi-container setup")
            print("  🔨 Makefile - Build automation")
            print("  📖 README_ENHANCED.md - Comprehensive documentation")
            
            print("\nNext steps:")
            print("  1. Test the enhanced setup: bash scripts/enhanced_setup.sh")
            print("  2. Try Make commands: make help")
            print("  3. Build Docker image: make docker-build")
            print("  4. Verify everything: make verify")
            
        except Exception as e:
            print(f"❌ Integration failed: {e}")
            return False
        
        return True

def main():
    """Main function."""
    print("🛡️  Linux Vulnerability Analysis Toolkit - Integration Script")
    print("=" * 60)
    
    integrator = ToolkitIntegrator()
    success = integrator.run_integration()
    
    if success:
        print("\n✅ All integration tasks completed successfully!")
    else:
        print("\n❌ Some integration tasks failed. Please check the output above.")
    
    return success

if __name__ == "__main__":
    main()
